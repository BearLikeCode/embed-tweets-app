{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\n\nclass TwitterPaginator {\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(_ref) {\n    let {\n      realData,\n      rateLimit,\n      instance,\n      queryParams,\n      sharedParams\n    } = _ref;\n    this._maxResultsWhenFetchLast = 100;\n    this._realData = realData;\n    this._rateLimit = rateLimit;\n    this._instance = instance;\n    this._queryParams = queryParams;\n    this._sharedParams = sharedParams;\n  }\n\n  get _isRateLimitOk() {\n    const resetDate = this._rateLimit.reset * 1000;\n\n    if (resetDate < Date.now()) {\n      return true;\n    }\n\n    return this._rateLimit.remaining > 0;\n  }\n\n  makeRequest(queryParams) {\n    return this._instance.get(this.getEndpoint(), queryParams, {\n      fullResponse: true,\n      params: this._sharedParams\n    });\n  }\n\n  makeNewInstanceFromResult(result, queryParams) {\n    // Construct a subclass\n    return new this.constructor({\n      realData: result.data,\n      rateLimit: result.rateLimit,\n      instance: this._instance,\n      queryParams,\n      sharedParams: this._sharedParams\n    });\n  }\n\n  getEndpoint() {\n    return this._endpoint;\n  }\n\n  injectQueryParams(maxResults) {\n    return { ...(maxResults ? {\n        max_results: maxResults\n      } : {}),\n      ...this._queryParams\n    };\n  }\n  /* ---------------------- */\n\n  /* Real paginator methods */\n\n  /* ---------------------- */\n\n  /**\n   * Next page.\n   */\n\n\n  async next(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Next page, but store it in current instance.\n   */\n\n\n  async fetchNext(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams); // Await in case of async sub-methods\n\n    await this.refreshInstanceFromResult(result, true);\n    return this;\n  }\n  /**\n   * Fetch up to {count} items after current page,\n   * as long as rate limit is not hit and Twitter has some results\n   */\n\n\n  async fetchLast() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    let resultCount = 0; // Break at rate limit limit\n\n    while (resultCount < count && this._isRateLimitOk) {\n      const response = await this.makeRequest(queryParams);\n      await this.refreshInstanceFromResult(response, true);\n      resultCount += this.getPageLengthFromRequest(response);\n\n      if (this.isFetchLastOver(response)) {\n        break;\n      }\n\n      queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    }\n\n    return this;\n  }\n\n  get rateLimit() {\n    return { ...this._rateLimit\n    };\n  }\n  /** Get raw data returned by Twitter API. */\n\n\n  get data() {\n    return this._realData;\n  }\n\n  get done() {\n    return !this.canFetchNextPage(this._realData);\n  }\n  /**\n   * Iterate over currently fetched items.\n   */\n\n\n  *[Symbol.iterator]() {\n    yield* this.getItemArray();\n  }\n  /**\n   * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more items available)\n   * This will **mutate the current instance** and fill data, metas, etc. inside this instance.\n   *\n   * If you need to handle concurrent requests, or you need to rely on immutability, please use `.fetchAndIterate()` instead.\n   */\n\n\n  async *[Symbol.asyncIterator]() {\n    yield* this.getItemArray(); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    let paginator = this;\n    let canFetchNextPage = this.canFetchNextPage(this._realData);\n\n    while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n      const next = await paginator.next(this._maxResultsWhenFetchLast); // Store data into current instance [needed to access includes and meta]\n\n      this.refreshInstanceFromResult({\n        data: next._realData,\n        headers: {},\n        rateLimit: next._rateLimit\n      }, true);\n      canFetchNextPage = this.canFetchNextPage(next._realData);\n      const items = next.getItemArray();\n      yield* items;\n      paginator = next;\n    }\n  }\n  /**\n   * Iterate over items \"undefinitely\" without modifying the current instance (until rate limit is hit / they're no more items available)\n   *\n   * This will **NOT** mutate the current instance, meaning that current instance will not inherit from `includes` and `meta` (v2 API only).\n   * Use `Symbol.asyncIterator` (`for-await of`) to directly access items with current instance mutation.\n   */\n\n\n  async *fetchAndIterate() {\n    for (const item of this.getItemArray()) {\n      yield [item, this];\n    } // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n\n    let paginator = this;\n    let canFetchNextPage = this.canFetchNextPage(this._realData);\n\n    while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n      const next = await paginator.next(this._maxResultsWhenFetchLast); // Store data into current instance [needed to access includes and meta]\n\n      this.refreshInstanceFromResult({\n        data: next._realData,\n        headers: {},\n        rateLimit: next._rateLimit\n      }, true);\n      canFetchNextPage = this.canFetchNextPage(next._realData);\n\n      for (const item of next.getItemArray()) {\n        yield [item, next];\n      }\n\n      this._rateLimit = next._rateLimit;\n      paginator = next;\n    }\n  }\n\n}\n\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\n\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n  /**\n   * Previous page (new tweets)\n   */\n  async previous(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Previous page, but in current instance.\n   */\n\n\n  async fetchPrevious(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    await this.refreshInstanceFromResult(result, false);\n    return this;\n  }\n\n}\n\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;","map":{"version":3,"names":["Object","defineProperty","exports","value","PreviousableTwitterPaginator","TwitterPaginator","constructor","realData","rateLimit","instance","queryParams","sharedParams","_maxResultsWhenFetchLast","_realData","_rateLimit","_instance","_queryParams","_sharedParams","_isRateLimitOk","resetDate","reset","Date","now","remaining","makeRequest","get","getEndpoint","fullResponse","params","makeNewInstanceFromResult","result","data","_endpoint","injectQueryParams","maxResults","max_results","next","getNextQueryParams","fetchNext","refreshInstanceFromResult","fetchLast","count","Infinity","resultCount","response","getPageLengthFromRequest","isFetchLastOver","done","canFetchNextPage","Symbol","iterator","getItemArray","asyncIterator","paginator","length","headers","items","fetchAndIterate","item","previous","getPreviousQueryParams","fetchPrevious","default"],"sources":["/Users/user/Sites/twits_app/twits/node_modules/twitter-api-v2/dist/paginators/TwitterPaginator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\nclass TwitterPaginator {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor({ realData, rateLimit, instance, queryParams, sharedParams }) {\n        this._maxResultsWhenFetchLast = 100;\n        this._realData = realData;\n        this._rateLimit = rateLimit;\n        this._instance = instance;\n        this._queryParams = queryParams;\n        this._sharedParams = sharedParams;\n    }\n    get _isRateLimitOk() {\n        const resetDate = this._rateLimit.reset * 1000;\n        if (resetDate < Date.now()) {\n            return true;\n        }\n        return this._rateLimit.remaining > 0;\n    }\n    makeRequest(queryParams) {\n        return this._instance.get(this.getEndpoint(), queryParams, { fullResponse: true, params: this._sharedParams });\n    }\n    makeNewInstanceFromResult(result, queryParams) {\n        // Construct a subclass\n        return new this.constructor({\n            realData: result.data,\n            rateLimit: result.rateLimit,\n            instance: this._instance,\n            queryParams,\n            sharedParams: this._sharedParams,\n        });\n    }\n    getEndpoint() {\n        return this._endpoint;\n    }\n    injectQueryParams(maxResults) {\n        return {\n            ...(maxResults ? { max_results: maxResults } : {}),\n            ...this._queryParams,\n        };\n    }\n    /* ---------------------- */\n    /* Real paginator methods */\n    /* ---------------------- */\n    /**\n     * Next page.\n     */\n    async next(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Next page, but store it in current instance.\n     */\n    async fetchNext(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        // Await in case of async sub-methods\n        await this.refreshInstanceFromResult(result, true);\n        return this;\n    }\n    /**\n     * Fetch up to {count} items after current page,\n     * as long as rate limit is not hit and Twitter has some results\n     */\n    async fetchLast(count = Infinity) {\n        let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        let resultCount = 0;\n        // Break at rate limit limit\n        while (resultCount < count && this._isRateLimitOk) {\n            const response = await this.makeRequest(queryParams);\n            await this.refreshInstanceFromResult(response, true);\n            resultCount += this.getPageLengthFromRequest(response);\n            if (this.isFetchLastOver(response)) {\n                break;\n            }\n            queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        }\n        return this;\n    }\n    get rateLimit() {\n        return { ...this._rateLimit };\n    }\n    /** Get raw data returned by Twitter API. */\n    get data() {\n        return this._realData;\n    }\n    get done() {\n        return !this.canFetchNextPage(this._realData);\n    }\n    /**\n     * Iterate over currently fetched items.\n     */\n    *[Symbol.iterator]() {\n        yield* this.getItemArray();\n    }\n    /**\n     * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more items available)\n     * This will **mutate the current instance** and fill data, metas, etc. inside this instance.\n     *\n     * If you need to handle concurrent requests, or you need to rely on immutability, please use `.fetchAndIterate()` instead.\n     */\n    async *[Symbol.asyncIterator]() {\n        yield* this.getItemArray();\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            // Store data into current instance [needed to access includes and meta]\n            this.refreshInstanceFromResult({ data: next._realData, headers: {}, rateLimit: next._rateLimit }, true);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            const items = next.getItemArray();\n            yield* items;\n            paginator = next;\n        }\n    }\n    /**\n     * Iterate over items \"undefinitely\" without modifying the current instance (until rate limit is hit / they're no more items available)\n     *\n     * This will **NOT** mutate the current instance, meaning that current instance will not inherit from `includes` and `meta` (v2 API only).\n     * Use `Symbol.asyncIterator` (`for-await of`) to directly access items with current instance mutation.\n     */\n    async *fetchAndIterate() {\n        for (const item of this.getItemArray()) {\n            yield [item, this];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            // Store data into current instance [needed to access includes and meta]\n            this.refreshInstanceFromResult({ data: next._realData, headers: {}, rateLimit: next._rateLimit }, true);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            for (const item of next.getItemArray()) {\n                yield [item, next];\n            }\n            this._rateLimit = next._rateLimit;\n            paginator = next;\n        }\n    }\n}\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n    /**\n     * Previous page (new tweets)\n     */\n    async previous(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Previous page, but in current instance.\n     */\n    async fetchPrevious(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        await this.refreshInstanceFromResult(result, false);\n        return this;\n    }\n}\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}